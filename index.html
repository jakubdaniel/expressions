<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>expressions-0.4.2: Expressions and Formulae a la carte</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">expressions-0.4.2: Expressions and Formulae a la carte</p></div><div id="content"><div id="description"><h1>expressions-0.4.2: Expressions and Formulae a la carte</h1><div class="doc"><p>This package is aimed at providing means of fixing a first-order language and
declaring sorted expressions and formulae, the types ensure the declared
expressions fall within the language.</p><p>This package pre-defines the common logical symbols for conjunction,
disjunction, negation, and universal and existential quantification as well
as some specific non-logical symbols such as equality, addition of linear
integer arithmetic, and other. Common languages such as Lia and ALia
(standard linear integer arithmetic and linear integer arithmetic with
arrays) come included.</p><p>An example of a formula declaration:</p><pre>-- Let's state that zero is successor to no integer (while this would be
-- true for non-negative integers, stated this way it is clearly false, but
-- it still is a well-formed first-order statement)

forall [var &quot;x&quot; :: Var 'IntegralSort] (cnst 0 ./=. var &quot;x&quot; .+. cnst 1) :: Lia 'BooleanSort</pre><p>Let's see what declarations the library rejects:</p><pre>(var &quot;x&quot; :: Lia 'BooleanSort) .=. (var &quot;y&quot; :: Lia 'IntegralSort)
(var &quot;x&quot; :: Lia 'BooleanSort) .=. (var &quot;y&quot; :: ALia 'BooleanSort)
forall [var &quot;x&quot; :: Var 'IntegralSort] true :: QFLia 'BooleanSort</pre></div></div><div id="module-list"><p class="caption">Signatures</p></div><div id="module-list"><p class="caption">Modules</p><ul><li><span class="module details-toggle-control details-toggle" data-details-id="n.1">Data</span><details id="n.1" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="details-toggle-control details-toggle" data-details-id="n.1.1">&nbsp;</span><a href="Data-Expression.html">Data.Expression</a></span><details id="n.1.1" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><a href="Data-Expression-Arithmetic.html">Data.Expression.Arithmetic</a></span></li><li><span class="module"><a href="Data-Expression-Array.html">Data.Expression.Array</a></span></li><li><span class="module"><a href="Data-Expression-Equality.html">Data.Expression.Equality</a></span></li><li><span class="module"><a href="Data-Expression-IfThenElse.html">Data.Expression.IfThenElse</a></span></li><li><span class="module"><a href="Data-Expression-Parser.html">Data.Expression.Parser</a></span></li><li><span class="module"><a href="Data-Expression-Sort.html">Data.Expression.Sort</a></span></li><li><span class="module details-toggle-control details-toggle" data-details-id="n.1.1.7">Utils</span><details id="n.1.1.7" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module details-toggle-control details-toggle" data-details-id="n.1.1.7.1">Indexed</span><details id="n.1.1.7.1" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><a href="Data-Expression-Utils-Indexed-Eq.html">Data.Expression.Utils.Indexed.Eq</a></span></li><li><span class="module"><a href="Data-Expression-Utils-Indexed-Foldable.html">Data.Expression.Utils.Indexed.Foldable</a></span></li><li><span class="module"><a href="Data-Expression-Utils-Indexed-Functor.html">Data.Expression.Utils.Indexed.Functor</a></span></li><li><span class="module"><a href="Data-Expression-Utils-Indexed-Show.html">Data.Expression.Utils.Indexed.Show</a></span></li><li><span class="module"><a href="Data-Expression-Utils-Indexed-Sum.html">Data.Expression.Utils.Indexed.Sum</a></span></li><li><span class="module"><a href="Data-Expression-Utils-Indexed-Traversable.html">Data.Expression.Utils.Indexed.Traversable</a></span></li></ul></details></li></ul></details></li></ul></details></li></ul></details></li></ul></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.20.0</p></div></body></html>